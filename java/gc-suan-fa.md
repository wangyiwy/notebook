# GC算法

### 引用计数（Reference counting）

对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一。当引用计数为0时则立即回收对象。

#### 优点

* 实现简单；
* 计算代价分散；
* 内存回收及时。

#### 缺点

* 占用额外内存空间；
* 并发支持较弱；
* 循环引用无法回收。

### 复制（Copying）

将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空。

#### 优点

* 实现简单；
* 不产生内存碎片。

#### 缺点

* 浪费了一半的内存；
* 如果对象的存活率较高，复制的开销比较大。

### 标记-清除 （Mark-Sweep）

算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。

#### 缺点

* 标记和清除过程的效率都不高；
* 标记清除之后会产生大量不连续的内存碎片。

### **标记-压缩（**Mark-Compact**）**

与标记清除算法一样，第一步把需要回收的对象标记，不同的是第二步不再对标记的对象做回收，而是通过所有存活对象都向一端移动，然后直接清除边界以外的内存。

#### 优点

不仅可以弥补标记-清除算法当中内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。

#### 缺点

效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记-压缩算法要低于复制算法。

### 标记清除压缩（Mark-Sweep-Compact）

标记清除压缩算法就是将**标记清除**算法与**标记压缩**算法结合起来。当多次GC之后才进行压缩，减少对象移动的成本。





