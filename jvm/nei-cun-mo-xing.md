# 内存划分



![image](https://pic4.zhimg.com/80/v2-abefb713de46f1e6dd241246c0afe263_hd.jpg)

* **方法区\(Method Area\)**

  存储类信息、常量、静态变量、即时编译器编译后的代码。 HotSpot虚拟机选择把GC分代收集扩展至方法区，因此对于HotSpot虚拟机来说方法区也叫永久代\(Permanent Generation\)。

  JVM规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。

  根据JVM规范，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

* **运行时常量池\(Runtime Constant Pool\)**

  方法区的一部分，用于存储编译器生成的字面量和符号引用。运行期也可以将新的常量放入池中，如 **String.intern\(\)**方法。

* **堆\(Heap\)**

  存储所有对象实例和数组，垃圾回收期主要管理的区域堆被划分成两个不同的区域：新生代 \( Young \)、老年代 \( Old \)。新生代 \( Young \) 又被划分为三个区域：Eden、From Survivor、To Survivor。

  根据JVM规范，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

* **程序计数器\(\)**

  程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器，用于线程切换后能恢复到正确的执行位置。

  如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。

  此内存区域是唯一一个JVM规范中没有规定任何OutOfMemoryError情况的区域。

* **Java虚拟机栈\(Java Vitual Machine Stacks\)**

  虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口、对象指针。每一个方法被调用到执行完成的过程，就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。

  JVM规范对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。

* **本地方法栈\(Native Method Stacks\)**

  本地方法栈和虚拟机栈的作用是非常相似的，本地方法栈则是为虚拟机使用到的Native方法服务。

  虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（比如HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

