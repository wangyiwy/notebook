# GC算法

### 引用计数（Reference counting）

对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一。当引用计数为0时则立即回收对象。

#### 优点

* 实现简单；
* 计算代价分散；
* 内存回收及时。

#### 缺点

* 占用额外内存空间；
* 并发支持较弱；
* 循环引用无法回收。

### 复制（Copying）

将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空。

#### 优点

* 实现简单；
* 不产生内存碎片。

#### 缺点

* 浪费了一半的内存；
* 如果对象的存活率较高，复制的开销比较大。

### 标记-清除 （Mark-Sweep）

算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。

#### 缺点

* 标记和清除过程的效率都不高；
* 标记清除之后会产生大量不连续的内存碎片。

### **标记-压缩（**Mark-Compact**）**

与标记清除算法一样，第一步把需要回收的对象标记，不同的是第二步不再对标记的对象做回收，而是通过所有存活对象都向一端移动，然后直接清除边界以外的内存。

#### 优点

不仅可以弥补标记-清除算法当中内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。

#### 缺点

效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记-压缩算法要低于复制算法。

### 标记清除压缩（Mark-Sweep-Compact）

标记清除压缩算法就是将**标记清除**算法与**标记压缩**算法结合起来。当多次GC之后才进行压缩，减少对象移动的成本。

### 分代收集

堆内存被分为**新生代**和**老年代**，其中新生代一般分为eden和Survivor\(上文简述过\)。在新生代的GC成为 minorGC，老年代的称为majorGC/fullGC，新创建的对象属于新生代，在经历了N次minorGC后\(N可调大小，默认15\)，会转到老年代。 新生代的区域和老年代区域比例一般为1：2。两个区域的垃圾收集算法都可以不同，新生代一般使用“复制算法”，老年代使用“标记-压缩法”。

**为什么新生代使用“复制算法”，老年代使用“标记-整理法”？**

因为大部分对象生命周期很短，很快会被回收的，所以新生代的minorGC的触发频率要远大于老年代的majorGC，这就需要效率更高的“复制算法”，而老年代由于majorGC触发频率比较低，所以可以选择效率较低的“标记整理法”来节约内存。

此外，值得一提的是新生代的eden内存要大于Survivor内存，这样就会出现一个问题：当eden中有一部分对象生命周期一样并且占用的内存大于Survivor时，执行minorGC仍然幸存，Survivor将无法存放这么多的对象。这时老年代就会起到“担保”作用，那些存活的对象将直接晋升到老年代。同理“复制算法”需要有人来做担保，这也是老年代使用“标记压缩法”的原因之一。 





